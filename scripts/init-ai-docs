#!/bin/bash

# EthPandaOps AI Documentation Initialization Script
# This script recursively initializes AI documentation for a project by:
# 1. Running init-project-ai-docs at the project root
# 2. Finding all directories with code and running init-component-ai-docs for each

set -e

# Default values
PROJECT_ROOT="."
DRY_RUN=false
VERBOSE=false

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS] [PROJECT_ROOT]

Initialize AI documentation for a project and its components.

Arguments:
  PROJECT_ROOT      Project directory to process (default: current directory)

Options:
  -n, --dry-run     Show what would be done without executing
  -v, --verbose     Enable verbose output
  -h, --help        Show this help message

Examples:
  # Initialize from current directory (simplest usage)
  $0

  # Initialize specific project directory
  $0 /path/to/project

  # Dry run to see what would happen
  $0 --dry-run
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            echo "Unknown option $1"
            usage
            exit 1
            ;;
        *)
            PROJECT_ROOT="$1"
            shift
            ;;
    esac
done

# No validation needed since PROJECT_ROOT defaults to current directory

# Check if claude is installed
if ! command -v claude &> /dev/null; then
    echo "Error: claude could not be found -- have you installed Claude Code? (https://docs.anthropic.com/en/docs/claude-code)"
    exit 1
fi

# Convert to absolute path and validate
if [ ! -d "$PROJECT_ROOT" ]; then
    echo "Error: Project directory does not exist: $PROJECT_ROOT"
    exit 1
fi

PROJECT_ROOT=$(cd "$PROJECT_ROOT" && pwd)

# Verbose logging function
log() {
    if [ "$VERBOSE" = true ] || [ "$DRY_RUN" = true ]; then
        echo "$@"
    fi
}

# Function to show progress timer with spinner
show_progress_timer() {
    local component_name="$1"
    local pid="$2"
    local start_time=$(date +%s)
    local spinner_chars="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
    local spinner_index=0
    
    # Hide cursor and save position
    printf "\033[?25l"
    
    while kill -0 "$pid" 2>/dev/null; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        
        # Get spinner character
        local spinner_char="${spinner_chars:$spinner_index:1}"
        spinner_index=$(( (spinner_index + 1) % ${#spinner_chars} ))
        
        # Clear line and show progress
        printf "\r\033[Küì¶ Processing: %-40s %s %02d:%02d" "$component_name" "$spinner_char" "$mins" "$secs"
        
        sleep 0.1
    done
    
    local end_time=$(date +%s)
    local total_elapsed=$((end_time - start_time))
    local total_mins=$((total_elapsed / 60))
    local total_secs=$((total_elapsed % 60))
    
    # Show completion and restore cursor
    printf "\r\033[Küì¶ Completed: %-40s ‚úÖ %02d:%02d\n" "$component_name" "$total_mins" "$total_secs"
    printf "\033[?25h"
}

# Execute or show command
execute() {
    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would execute: $*"
    else
        log "Executing: $*"
        "$@"
    fi
}

# Execute with progress timer
execute_with_progress() {
    local component_name="$1"
    shift
    
    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would execute: $*"
    else
        log "Executing with progress: $*"
        # Run command in background and show progress timer
        "$@" > /dev/null 2>&1 &
        local cmd_pid=$!
        
        show_progress_timer "$component_name" "$cmd_pid"
        
        # Wait for command to complete and get exit status
        wait "$cmd_pid"
        local exit_status=$?
        
        if [ $exit_status -ne 0 ]; then
            echo "‚ùå Command failed with exit status $exit_status"
            return $exit_status
        fi
    fi
}

echo "üêº ethPandaOps AI Documentation Initialization"
echo "============================================="
echo "Project directory: $PROJECT_ROOT"
echo ""

# Show planning phase
echo "üìã Planning documentation structure..."
echo ""

# Find directories that likely contain code
echo "üîç Scanning project structure..."

# Define patterns for directories that likely contain code
CODE_PATTERNS=(
    "*/src/*"
    "*/lib/*"
    "*/pkg/*"
    "*/cmd/*"
    "*/internal/*"
    "*/api/*"
    "*/services/*"
    "*/components/*"
    "*/modules/*"
    "*/handlers/*"
    "*/controllers/*"
    "*/models/*"
    "*/utils/*"
    "*/tools/*"
)

# Find directories with code files
COMPONENT_DIRS=()

# Look for directories with common code file extensions
while IFS= read -r -d '' dir; do
    # Skip the project root directory itself
    if [ "$dir" = "$PROJECT_ROOT" ]; then
        continue
    fi
    
    # Skip hidden directories, node_modules, vendor, etc.
    if echo "$dir" | grep -qE "\/(\..*|node_modules|vendor|build|dist|target|static|__pycache__|\.git)\/"; then
        continue
    fi
    
    # Skip directories that only contain other directories (no files at all)
    if ! find "$dir" -maxdepth 1 -type f | grep -q .; then
        continue
    fi
    
    # Check if directory contains code files
    if find "$dir" -maxdepth 1 -type f \( \
        -name "*.go" -o \
        -name "*.ts" -o \
        -name "*.js" -o \
        -name "*.py" -o \
        -name "*.rs" -o \
        -name "*.java" -o \
        -name "*.cpp" -o \
        -name "*.c" -o \
        -name "*.h" \
        \) | grep -q .; then
        COMPONENT_DIRS+=("$dir")
    fi
done < <(find "$PROJECT_ROOT" -type d -print0)

# Sort directories by depth and name for consistent processing
IFS=$'\n' COMPONENT_DIRS=($(printf '%s\n' "${COMPONENT_DIRS[@]}" | sort))

# Show the plan
echo ""
echo "üìã Documentation Plan"
echo "=================="
echo ""
echo "üéØ Project Root:"
echo "   ‚îú‚îÄ‚îÄ CLAUDE.md"
echo "   ‚îú‚îÄ‚îÄ .cursor/"
echo "   ‚îÇ   ‚îî‚îÄ‚îÄ rules/"
echo "   ‚îÇ       ‚îú‚îÄ‚îÄ project_architecture.mdc"
echo "   ‚îÇ       ‚îú‚îÄ‚îÄ code_standards.mdc"
echo "   ‚îÇ       ‚îî‚îÄ‚îÄ development_workflow.mdc"
echo "   ‚îú‚îÄ‚îÄ llms/ -> .cursor (symlink)"
echo "   ‚îî‚îÄ‚îÄ .roo/ -> .cursor (symlink)"
echo ""

if [ ${#COMPONENT_DIRS[@]} -eq 0 ]; then
    echo "‚ö†Ô∏è  No component directories found"
else
    echo "üì¶ Components (${#COMPONENT_DIRS[@]} directories):"
    
    # Show all components with tree structure
    count=0
    for component_dir in "${COMPONENT_DIRS[@]}"; do
        rel_path=$(python3 -c "import os.path; print(os.path.relpath('$component_dir', '$PROJECT_ROOT'))")
        
        if [ $count -eq $((${#COMPONENT_DIRS[@]} - 1)) ]; then
            echo "   ‚îî‚îÄ‚îÄ $rel_path/"
            echo "       ‚îî‚îÄ‚îÄ CLAUDE.md"
        else
            echo "   ‚îú‚îÄ‚îÄ $rel_path/"
            echo "   ‚îÇ   ‚îî‚îÄ‚îÄ CLAUDE.md"
        fi
        
        ((count++))
    done
fi

echo ""
echo "üìä Summary:"
echo "   ‚Ä¢ Will create 1 project root with .cursor/rules/ structure"
echo "   ‚Ä¢ Will create CLAUDE.md in ${#COMPONENT_DIRS[@]} component directories"
echo "   ‚Ä¢ Each component CLAUDE.md references project root rules, and will create an equivalent rule in .cursor/rules/"
echo ""

# Confirmation prompt
if [ "$DRY_RUN" = false ]; then
    read -p "ü§î Proceed with this plan? [y/N]: " confirm
    case $confirm in
        [yY]|[yY][eE][sS])
            echo "‚úÖ Starting documentation generation..."
            ;;
        *)
            echo "‚ùå Cancelled by user"
            exit 0
            ;;
    esac
    echo ""
fi

# Initialize project-level documentation
echo "üìã Initializing project-level documentation..."
execute_with_progress "Project Root" claude -p --dangerously-skip-permissions "/init-project-ai-docs" "project-root=$PROJECT_ROOT"
echo ""

if [ ${#COMPONENT_DIRS[@]} -gt 0 ]; then
    echo "üì¶ Processing components..."
    
    # Process each component directory
    for component_dir in "${COMPONENT_DIRS[@]}"; do
        rel_path=$(python3 -c "import os.path; print(os.path.relpath('$component_dir', '$PROJECT_ROOT'))")
        
        execute_with_progress "$rel_path" claude -p --dangerously-skip-permissions "/init-component-ai-docs" "project-root=$PROJECT_ROOT,component-dir=$component_dir"
    done
fi

echo ""
if [ "$DRY_RUN" = true ]; then
    echo "üîç Dry run completed. Use without --dry-run to execute."
else
    echo "‚úÖ AI documentation initialization completed!"
    echo ""
    echo "üìã Summary:"
    echo "   ‚Ä¢ Project root processed: $PROJECT_ROOT"
    echo "   ‚Ä¢ Components processed: ${#COMPONENT_DIRS[@]}"
    echo ""
    echo "üöÄ Next steps:"
    echo "   ‚Ä¢ Review generated CLAUDE.md files"
    echo "   ‚Ä¢ Review generated .cursor/rules/*.mdc files"
    echo "   ‚Ä¢ Customize the documentation as needed"
fi